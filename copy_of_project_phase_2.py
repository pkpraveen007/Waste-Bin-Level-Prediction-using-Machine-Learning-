# -*- coding: utf-8 -*-
"""Copy of Project_Phase_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P_M8LA03xyWsYDyB4YMwefO2cTL0Eh8L

# **Develop a machine learning model to predict the fill level of waste bins based on historical data.**
"""

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.impute import SimpleImputer
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error

"""# **1 - Loading Data**"""

# Load the dataset
data = pd.read_csv("bin.csv")

data.head()

data.info()

"""# **2 -Data Preprocessing**"""

# Data Preprocessing
data['binClearedTime'] = pd.to_datetime(data['binClearedTime'])
data['observationDateTime'] = pd.to_datetime(data['observationDateTime'])

data.info()

"""# **3 - Feature engineering**"""

# Feature engineering
data['hour'] = data['observationDateTime'].dt.hour
data['day_of_week'] = data['observationDateTime'].dt.dayofweek
data['binClearedTime_hour'] = data['binClearedTime'].dt.hour

# Prepare features and target variable
X = data[['hour', 'day_of_week', 'binClearedTime_hour']]
y = data['binFillingLevel']

"""# **4 -Split the data into training and testing sets**"""

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
# Impute missing values with the mean of each column
imputer = SimpleImputer(strategy='mean')
X_train_imputed = imputer.fit_transform(X_train)
X_test_imputed = imputer.transform(X_test)

"""# **5 -Train a linear regression model on the imputed data**"""

# Train a linear regression model on the imputed data
model = LinearRegression()
model.fit(X_train_imputed, y_train)
# Make predictions on the test set
y_pred = model.predict(X_test_imputed)

"""# **6-Evaluating the model**


"""

mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f'Mean Squared Error: {mse}')
print(f'R-squared: {r2}')

"""# To Develop a machine learning model to predict the fill level of waste bins based on historical data

# **Plotting Three Graphs**
"""

# Plotting the predicted vs actual values
plt.scatter(y_test, y_pred)

# Plotting the distribution of the target variable
plt.hist(data['binFillingLevel'], bins=20, color='blue', alpha=0.7, label='Actual')
plt.hist(y_pred, bins=20, color='orange', alpha=0.7, label='Predicted')
plt.xlabel('Bin Filling Level')
plt.ylabel('Frequency')
plt.title('Distribution of Bin Filling Level')
plt.legend()
plt.show()

# Plotting the model coefficients
coefficients = pd.Series(model.coef_, index=X.columns)
coefficients.plot(kind='bar')
plt.title('Model Coefficients')
plt.show()

"""# **Implement a machine learning algorithm to optimize waste collection routes by considering predicted fill levels of multiple bins.**"""

# Assuming the column names are 'observationDateTime' and 'binFillingLevel'
data['observationDateTime'] = pd.to_datetime(data['observationDateTime'])
data.set_index('observationDateTime', inplace=True)

data.info()

"""# **7 -Check the data types of columns**"""

# Check the data types of columns
print(data.dtypes)

# Ensure 'binFillingLevel' is of numeric type
data['binFillingLevel'] = pd.to_numeric(data['binFillingLevel'], errors='coerce')

# Drop rows with missing values
data = data.dropna()

"""# **8 â€“Split the data into training and testing sets**"""

# Split the data into training and testing sets
train_size = int(len(data) * 0.5)
train, test = data[:train_size], data[train_size:]

"""# **9-Implementing The ARIMA & SARIMA Model**"""

# ARIMA model
order = (0, 0, 1)  # Example order, you need to tune these values
arima_model = ARIMA(train['binFillingLevel'], order=order)
arima_fit = arima_model.fit()

# SARIMA model
seasonal_order = (0, 0, 0, 0)  # Example seasonal order, you need to tune these values
sarima_model = SARIMAX(train['binFillingLevel'], order=order, seasonal_order=seasonal_order)
sarima_fit = sarima_model.fit()

"""# **Forcasting the ARIMA and SARIMA Model**"""

# Forecast using ARIMA
arima_forecast = arima_fit.predict(start=len(train), end=len(train) + len(test) - 1, typ='levels')

# Forecast using SARIMA
sarima_forecast = sarima_fit.predict(start=len(train), end=len(train) + len(test) - 1, typ='levels')

# Calculate MSE for ARIMA forecast
arima_mse = mean_squared_error(test['binFillingLevel'], arima_forecast)

# Calculate MSE for SARIMA forecast
sarima_mse = mean_squared_error(test['binFillingLevel'], sarima_forecast)

# Calculate R-squared for ARIMA forecast
arima_r2 = r2_score(test['binFillingLevel'], arima_forecast)

# Calculate R-squared for SARIMA forecast
sarima_r2 = r2_score(test['binFillingLevel'], sarima_forecast)

print(f"Overall Accuracy - ARIMA: {arima_r2:.1%}")
print(f"Overall Accuracy - SARIMA: {sarima_r2:.1%}")

"""# **Plotting Three Graphs**"""

# Histogram for Original Time Series
plt.subplot(1, 3, 1)
data['binFillingLevel'].plot(kind='hist', bins=20, edgecolor='black')
plt.title('Histogram - Original Time Series')
plt.xlabel('Bin Filling Level')
plt.ylabel('Frequency')

# Histogram for ARIMA Forecast
plt.subplot(1, 3, 2)
arima_forecast.plot(kind='hist', bins=20, edgecolor='black')
plt.title(f'Histogram - ARIMA Forecast\nMSE: {arima_mse:.2f}')
plt.xlabel('Bin Filling Level')
plt.ylabel('Frequency')

# Histogram for SARIMA Forecast
plt.subplot(1, 3, 3)
sarima_forecast.plot(kind='hist', bins=20, edgecolor='black')
plt.title(f'Histogram - SARIMA Forecast\nMSE: {sarima_mse:.2f}')
plt.xlabel('Bin Filling Level')
plt.ylabel('Frequency')

plt.tight_layout()
plt.show()

"""# **Future Forcasting**"""

import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX

data = pd.read_csv('bin.csv')

# Convert string datetime to pandas datetime object
data['observationDateTime'] = pd.to_datetime(data['observationDateTime'])

# Sort data by observationDateTime
data.sort_values(by='observationDateTime', inplace=True)

# Split data into train and test sets
train_size = int(0.8 * len(data))
train, test = data[:train_size], data[train_size:]

"""# **Returing Linear Regression,ARIMA and SARIMA Model for future forecasting**"""

# Linear Regression Model
regression_model = LinearRegression()
regression_model.fit(train[['binFillingLevel']], train['binFillingLevel'])

# ARIMA Model
arima_model = ARIMA(train['binFillingLevel'], order=(5,1,0))
arima_result = arima_model.fit()

# SARIMA Model
sarima_model = SARIMAX(train['binFillingLevel'], order=(1, 1, 1), seasonal_order=(1, 1, 1, 12))
sarima_result = sarima_model.fit()

"""# **Future forecasting using Linear Regression,ARIMA and SARIMA Models**"""

# Forecast future bin filling levels
future_dates = pd.date_range(start=data['observationDateTime'].max(), periods=10, freq='D')
last_observed_bin_filling_level = data['binFillingLevel'].iloc[-1]  # Get the last observed bin filling level
future_dates_df = pd.DataFrame({'observationDateTime': future_dates, 'binFillingLevel': [last_observed_bin_filling_level] * 10})

# Linear Regression Forecast
linear_regression_forecast = regression_model.predict(future_dates_df[['binFillingLevel']])
linear_regression_forecast_df = pd.DataFrame({'observationDateTime': future_dates, 'binFillingLevel': linear_regression_forecast})

# ARIMA Forecast
arima_forecast = arima_result.forecast(steps=10)
arima_forecast_df = pd.DataFrame({'observationDateTime': future_dates, 'binFillingLevel': arima_forecast})

# SARIMA Forecast
sarima_forecast = sarima_result.forecast(steps=10)
sarima_forecast_df = pd.DataFrame({'observationDateTime': future_dates, 'binFillingLevel': sarima_forecast})

"""# **Printing the forcasting Values**"""

# Print forecasts
print("\033[1mLinear Regression Future Forecast:\033[0m")
print(linear_regression_forecast_df.to_string(index=False))

print("\033[1mARIMA Future Forecast:\033[0m")
print(arima_forecast_df.to_string(index=False))

print("\033[1mSARIMA Future Forecast:\033[0m")
print(sarima_forecast_df.to_string(index=False))